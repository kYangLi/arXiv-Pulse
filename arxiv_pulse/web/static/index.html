<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>arXiv Pulse - è®ºæ–‡ç®¡ç†</title>
    <style>
        [v-cloak] { display: none; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f7fa; }
        .app-container { min-height: 100vh; }
        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px 40px; }
        .header h1 { font-size: 24px; margin-bottom: 5px; }
        .header p { opacity: 0.8; font-size: 14px; }
        .main-content { padding: 20px 40px; max-width: 1400px; margin: 0 auto; }
        .stats-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 20px; }
        .stat-card { background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); }
        .stat-card h3 { color: #909399; font-size: 14px; margin-bottom: 10px; }
        .stat-card .value { font-size: 28px; font-weight: bold; color: #303133; }
        .tabs-container { margin-bottom: 20px; }
        
        .paper-card { background: white; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); transition: all 0.3s; }
        .paper-card:hover { box-shadow: 0 4px 16px rgba(0,0,0,0.15); }
        .paper-title { color: #409EFF; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 8px; line-height: 1.4; }
        .paper-title:hover { text-decoration: underline; }
        .paper-title-cn { color: #606266; font-size: 14px; margin-bottom: 8px; line-height: 1.4; }
        .paper-meta { color: #909399; font-size: 13px; margin-bottom: 10px; display: flex; flex-wrap: wrap; gap: 15px; }
        .paper-meta-item { display: flex; align-items: center; gap: 4px; }
        .paper-category { background: #f0f2f5; padding: 4px 8px; border-radius: 4px; font-size: 12px; color: #606266; }
        .paper-relevance { font-size: 14px; }
        .paper-relevance .star { color: #f7ba2a; }
        .paper-abstract-preview { color: #606266; font-size: 14px; line-height: 1.6; margin-bottom: 10px; }
        .paper-actions { display: flex; gap: 10px; flex-wrap: wrap; }
        .expand-btn { color: #409EFF; cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 4px; margin-top: 10px; }
        .expand-btn:hover { text-decoration: underline; }
        
        .paper-detail { margin-top: 15px; padding-top: 15px; border-top: 1px solid #ebeef5; }
        .key-findings { background: #fdf6ec; padding: 12px 15px; border-radius: 6px; margin-bottom: 15px; }
        .key-findings h4 { color: #e6a23c; font-size: 14px; margin-bottom: 8px; }
        .key-findings ul { margin: 0; padding-left: 20px; }
        .key-findings li { color: #606266; font-size: 13px; line-height: 1.6; margin-bottom: 4px; }
        .paper-figure { margin-bottom: 15px; text-align: center; }
        .paper-figure img { max-width: 100%; max-height: 400px; border-radius: 8px; cursor: pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.1); transition: transform 0.2s; }
        .paper-figure img:hover { transform: scale(1.02); }
        .abstract-section { margin-bottom: 15px; }
        .abstract-section h4 { color: #303133; font-size: 14px; margin-bottom: 8px; }
        .abstract-section p { color: #606266; font-size: 14px; line-height: 1.8; }
        .abstract-section .translation { background: #f0f9eb; padding: 12px 15px; border-radius: 6px; margin-top: 10px; }
        
        .search-options { background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); }
        .search-options-row { display: flex; gap: 15px; flex-wrap: wrap; align-items: flex-end; }
        .search-options-row .el-input { flex: 1; min-width: 300px; }
        
        .recent-header { background: white; border-radius: 8px; padding: 15px 20px; margin-bottom: 20px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; }
        .recent-header .status-info { display: flex; align-items: center; gap: 15px; }
        .recent-header .status-info .label { color: #909399; font-size: 14px; }
        .recent-header .status-info .value { color: #303133; font-size: 14px; font-weight: 500; }
        
        .sync-status-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px; }
        .sync-status-card { background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); text-align: center; }
        .sync-status-card .icon { font-size: 24px; margin-bottom: 8px; }
        .sync-status-card .label { color: #909399; font-size: 13px; margin-bottom: 5px; }
        .sync-status-card .value { color: #303133; font-size: 16px; font-weight: 600; }
        .sync-status-card .value.success { color: #67c23a; }
        .sync-status-card .value.warning { color: #e6a23c; }
        
        .charts-row { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px; }
        .chart-card { background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); }
        .chart-card h3 { margin-bottom: 15px; color: #303133; font-size: 16px; }
        .chart-container { height: 300px; }
        
        .sync-options { background: white; border-radius: 8px; padding: 20px; margin-bottom: 20px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); }
        .sync-options h3 { margin-bottom: 15px; color: #303133; font-size: 16px; }
        .sync-options-row { display: flex; gap: 20px; flex-wrap: wrap; align-items: center; }
        .sync-options-row .option-item { display: flex; align-items: center; gap: 10px; }
        
        .logs-container { background: #1e1e1e; border-radius: 8px; padding: 15px; margin-bottom: 20px; min-height: 100px; max-height: 250px; overflow-y: auto; font-family: 'Monaco', 'Menlo', monospace; }
        .logs-container .log-line { color: #d4d4d4; font-size: 13px; line-height: 1.6; margin-bottom: 4px; }
        .logs-container .log-line.info { color: #4ec9b0; }
        .logs-container .log-line.success { color: #6a9955; }
        .logs-container .log-line.error { color: #f14c4c; }
        .logs-container .log-line.progress { color: #dcdcaa; }
        .logs-container .log-line.ai { color: #ce9178; }
        
        .collection-item { background: white; border-radius: 8px; padding: 15px; margin-bottom: 10px; box-shadow: 0 2px 12px rgba(0,0,0,0.1); cursor: pointer; transition: all 0.3s; }
        .collection-item:hover { box-shadow: 0 4px 16px rgba(0,0,0,0.15); transform: translateY(-2px); }
        .collection-item h4 { margin-bottom: 5px; display: flex; align-items: center; gap: 8px; }
        .collection-item p { color: #909399; font-size: 13px; }
        
        .loading { text-align: center; padding: 40px; color: #909399; }
        .empty-state { text-align: center; padding: 60px 20px; color: #909399; }
        .empty-state .el-icon { font-size: 48px; margin-bottom: 15px; }
    </style>
</head>
<body>
    <div id="app" v-cloak>
        <div class="app-container">
            <header class="header">
                <h1>arXiv Pulse</h1>
                <p>æ™ºèƒ½æ–‡çŒ®è¿½è¸ªä¸åˆ†æç³»ç»Ÿ</p>
            </header>

            <main class="main-content">
                <div class="stats-row" v-if="stats">
                    <div class="stat-card">
                        <h3>æ€»è®ºæ–‡æ•°</h3>
                        <div class="value">{{ stats.papers.total }}</div>
                    </div>
                    <div class="stat-card">
                        <h3>æœ¬å‘¨æ–°å¢</h3>
                        <div class="value">{{ stats.papers.this_week }}</div>
                    </div>
                    <div class="stat-card">
                        <h3>å·²æ€»ç»“</h3>
                        <div class="value">{{ stats.papers.summarized }}</div>
                    </div>
                    <div class="stat-card">
                        <h3>è®ºæ–‡é›†</h3>
                        <div class="value">{{ stats.collections.total }}</div>
                    </div>
                </div>

                <div class="tabs-container">
                    <el-tabs v-model="activeTab">
                        <el-tab-pane label="æœ€è¿‘è®ºæ–‡" name="recent"></el-tab-pane>
                        <el-tab-pane label="æœç´¢" name="search"></el-tab-pane>
                        <el-tab-pane label="æ•°æ®åº“æ¦‚è§ˆ" name="sync"></el-tab-pane>
                        <el-tab-pane label="è®ºæ–‡é›†" name="collections"></el-tab-pane>
                    </el-tabs>
                </div>

                <div v-show="activeTab === 'recent'">
                    <div class="sync-options" style="margin-bottom: 20px;">
                        <div class="sync-options-row" style="flex-wrap: wrap;">
                            <div class="option-item">
                                <span style="color: #606266;">æ—¶é—´èŒƒå›´:</span>
                                <el-select v-model="recentDays" style="width: 120px;" :disabled="updatingRecent">
                                    <el-option v-for="item in daysOptions" :key="item.value" :label="item.label" :value="item.value" />
                                </el-select>
                            </div>
                            <div class="option-item">
                                <span style="color: #606266;">æœ€å¤§æ•°é‡:</span>
                                <el-select v-model="recentLimit" style="width: 100px;" :disabled="updatingRecent">
                                    <el-option v-for="item in limitOptions" :key="item.value" :label="item.label" :value="item.value" />
                                </el-select>
                            </div>
                            <div class="option-item">
                                <span style="color: #606266;">é¢†åŸŸ:</span>
                                <el-select v-model="recentCategories" multiple collapse-tags collapse-tags-tooltip 
                                           style="width: 280px;" :disabled="updatingRecent" placeholder="å…¨éƒ¨é¢†åŸŸ">
                                    <el-option v-for="cat in categoryOptions" :key="cat.value" 
                                               :label="cat.label" :value="cat.value" />
                                </el-select>
                            </div>
                            <div class="option-item">
                                <el-checkbox v-model="recentNeedSync" :disabled="updatingRecent">
                                    å…ˆåŒæ­¥æ•°æ®åº“
                                </el-checkbox>
                            </div>
                            <div class="option-item" v-if="recentNeedSync">
                                <span style="color: #606266;">åŒæ­¥å¹´æ•°:</span>
                                <el-select v-model="recentSyncYears" style="width: 100px;" :disabled="updatingRecent">
                                    <el-option v-for="item in syncYearOptions" :key="item.value" :label="item.label" :value="item.value" />
                                </el-select>
                            </div>
                            <el-button type="primary" @click="updateRecentPapers" :loading="updatingRecent">
                                <el-icon><Refresh /></el-icon>
                                {{ updatingRecent ? 'æ›´æ–°ä¸­...' : 'è·å–æœ€è¿‘è®ºæ–‡' }}
                            </el-button>
                        </div>
                        <div style="margin-top: 10px; color: #909399; font-size: 13px;">
                            ç¼“å­˜çŠ¶æ€: {{ recentCacheStatus }}
                        </div>
                    </div>

                    <div v-if="recentLogs.length > 0" class="logs-container">
                        <div v-for="(log, index) in recentLogs" :key="index" 
                             class="log-line" 
                             :class="log.type">
                            > {{ log.message }}
                        </div>
                    </div>

                    <div v-if="loadingRecent" class="loading">
                        <el-icon class="is-loading" :size="32"><Loading /></el-icon>
                        <p style="margin-top: 15px;">åŠ è½½ä¸­...</p>
                    </div>
                    <div v-else-if="recentPapers.length === 0" class="empty-state">
                        <el-icon><Document /></el-icon>
                        <p>æš‚æ— æœ€è¿‘è®ºæ–‡ï¼Œç‚¹å‡»"æ›´æ–°æœ€è¿‘è®ºæ–‡"è·å–</p>
                    </div>
                    <div v-else>
                        <paper-card 
                            v-for="paper in recentPapers" 
                            :key="paper.id" 
                            :paper="paper"
                            :collections="collections"
                            @add-to-collection="addToCollection"
                        />
                    </div>
                </div>

                <div v-show="activeTab === 'search'">
                    <div class="search-options">
                        <div class="search-options-row">
                            <el-input 
                                v-model="searchQuery" 
                                placeholder="è¾“å…¥æœç´¢å…³é”®è¯ï¼ˆæ”¯æŒä¸­è‹±æ–‡è‡ªç„¶è¯­è¨€ï¼‰..." 
                                @keyup.enter="startSearch"
                                clearable
                                size="large"
                            >
                                <template #prefix>
                                    <el-icon><Search /></el-icon>
                                </template>
                            </el-input>
                            <el-select v-model="searchDays" placeholder="æ—¶é—´èŒƒå›´" style="width: 150px;" size="large" clearable>
                                <el-option v-for="item in searchDaysOptions" :key="item.value" :label="item.label" :value="item.value" />
                            </el-select>
                            <el-button type="primary" size="large" @click="startSearch" :loading="searching">
                                æœç´¢
                            </el-button>
                        </div>
                    </div>

                    <div v-if="searchLogs.length > 0" class="logs-container">
                        <div v-for="(log, index) in searchLogs" :key="index" 
                             class="log-line" 
                             :class="log.type">
                            > {{ log.message }}
                        </div>
                    </div>

                    <div v-if="searching" class="loading">
                        <el-icon class="is-loading" :size="32"><Loading /></el-icon>
                        <p style="margin-top: 15px;">æ­£åœ¨æœç´¢...</p>
                    </div>
                    <div v-else-if="searchResults.length > 0">
                        <p style="margin-bottom: 15px; color: #606266;">æ‰¾åˆ° {{ searchResults.length }} ç¯‡è®ºæ–‡</p>
                        <paper-card 
                            v-for="paper in searchResults" 
                            :key="paper.id" 
                            :paper="paper"
                            :collections="collections"
                            @add-to-collection="addToCollection"
                        />
                    </div>
                    <div v-else-if="searchQuery && !searching && searchLogs.length === 0" class="empty-state">
                        <el-icon><Search /></el-icon>
                        <p>è¾“å…¥å…³é”®è¯å¼€å§‹æœç´¢</p>
                    </div>
                </div>

                <div v-show="activeTab === 'sync'">
                    <div class="sync-status-grid" v-if="syncStatus">
                        <div class="sync-status-card">
                            <div class="icon">ğŸ“š</div>
                            <div class="label">æ€»è®ºæ–‡æ•°</div>
                            <div class="value">{{ syncStatus.database?.total_papers || 0 }}</div>
                        </div>
                        <div class="sync-status-card">
                            <div class="icon">ğŸ“…</div>
                            <div class="label">æœ€æ–°è®ºæ–‡æ—¥æœŸ</div>
                            <div class="value">{{ syncStatus.database?.latest_paper || '-' }}</div>
                        </div>
                        <div class="sync-status-card">
                            <div class="icon">ğŸ•</div>
                            <div class="label">æœ€ååŒæ­¥</div>
                            <div class="value" :class="syncTimeClass">{{ formatSyncTime(syncStatus.last_sync?.time) }}</div>
                        </div>
                        <div class="sync-status-card">
                            <div class="icon">ğŸ“Š</div>
                            <div class="label">åŒæ­¥çŠ¶æ€</div>
                            <div class="value" :class="syncStatusClass">{{ syncStatusText }}</div>
                        </div>
                    </div>

                    <div class="charts-row" v-if="stats">
                        <div class="chart-card">
                            <h3>ğŸ“ˆ å¹´ä»½åˆ†å¸ƒ</h3>
                            <div id="yearChart" class="chart-container"></div>
                        </div>
                        <div class="chart-card">
                            <h3>ğŸ·ï¸ ç ”ç©¶é¢†åŸŸåˆ†å¸ƒ (Top 10)</h3>
                            <div id="categoryChart" class="chart-container"></div>
                        </div>
                    </div>

                    <div class="sync-options">
                        <h3>åŒæ­¥é€‰é¡¹</h3>
                        <div class="sync-options-row">
                            <div class="option-item">
                                <span style="color: #606266;">å›æº¯å¹´æ•°:</span>
                                <el-select v-model="syncYearsBack" style="width: 120px;" :disabled="syncing">
                                    <el-option v-for="item in syncYearsBackOptions" :key="item.value" :label="item.label" :value="item.value" />
                                </el-select>
                            </div>
                            <div class="option-item">
                                <el-checkbox v-model="syncForce" :disabled="syncing">
                                    å¼ºåˆ¶åŒæ­¥ï¼ˆè·³è¿‡å·²å­˜åœ¨çš„è®ºæ–‡ï¼‰
                                </el-checkbox>
                            </div>
                            <el-button 
                                type="primary" 
                                size="large" 
                                @click="startSync" 
                                :loading="syncing"
                                :disabled="syncing"
                            >
                                <el-icon><Refresh /></el-icon>
                                {{ syncing ? 'åŒæ­¥ä¸­...' : 'å¼€å§‹åŒæ­¥' }}
                            </el-button>
                        </div>
                    </div>

                    <div v-if="syncLogs.length > 0 || syncing" class="logs-container">
                        <div v-for="(log, index) in syncLogs" :key="index" 
                             class="log-line" 
                             :class="log.type">
                            > {{ log.message }}
                        </div>
                        <div v-if="syncing" class="log-line info">> ç­‰å¾…å“åº”...</div>
                    </div>
                </div>

                <div v-show="activeTab === 'collections'">
                    <div v-if="!viewingCollection">
                        <el-button type="primary" @click="showCreateCollection = true" style="margin-bottom: 20px;">
                            <el-icon><Plus /></el-icon>
                            æ–°å»ºè®ºæ–‡é›†
                        </el-button>

                        <div v-if="collections.length === 0" class="empty-state">
                            <el-icon><Folder /></el-icon>
                            <p>æš‚æ— è®ºæ–‡é›†ï¼Œç‚¹å‡»ä¸Šæ–¹æŒ‰é’®åˆ›å»º</p>
                        </div>

                        <div class="collection-item" v-for="col in collections" :key="col.id">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                                <div style="flex: 1; cursor: pointer;" @click="openCollectionDetail(col)">
                                    <h4>
                                        <span :style="{ color: col.color }">â—</span>
                                        {{ col.name }}
                                    </h4>
                                    <p>{{ col.description || 'æš‚æ— æè¿°' }}</p>
                                    <p style="margin-top: 5px; color: #909399; font-size: 12px;">{{ col.paper_count || 0 }} ç¯‡è®ºæ–‡</p>
                                </div>
                                <div style="display: flex; gap: 5px;">
                                    <el-button size="small" text @click.stop="openEditCollection(col)">
                                        <el-icon><Edit /></el-icon>
                                    </el-button>
                                    <el-button size="small" text type="danger" @click.stop="confirmDeleteCollection(col)">
                                        <el-icon><Delete /></el-icon>
                                    </el-button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div v-else>
                        <div style="margin-bottom: 20px;">
                            <el-button @click="viewingCollection = null" text>
                                <el-icon><ArrowLeft /></el-icon>
                                è¿”å›åˆ—è¡¨
                            </el-button>
                        </div>
                        <div class="paper-card" style="margin-bottom: 20px;">
                            <h2 style="display: flex; align-items: center; gap: 10px;">
                                <span :style="{ color: viewingCollection.color }">â—</span>
                                {{ viewingCollection.name }}
                            </h2>
                            <p style="color: #909399; margin-top: 5px;">{{ viewingCollection.description || 'æš‚æ— æè¿°' }}</p>
                            <p style="color: #606266; margin-top: 10px;">å…± {{ collectionPapers.length }} ç¯‡è®ºæ–‡</p>
                        </div>

                        <div v-if="loadingCollectionPapers" class="loading">
                            <el-icon class="is-loading" :size="32"><Loading /></el-icon>
                            <p style="margin-top: 15px;">åŠ è½½ä¸­...</p>
                        </div>
                        <div v-else-if="collectionPapers.length === 0" class="empty-state">
                            <el-icon><Document /></el-icon>
                            <p>è®ºæ–‡é›†ä¸­æš‚æ— è®ºæ–‡</p>
                        </div>
                        <div v-else>
                            <div v-for="paper in collectionPapers" :key="paper.id" style="position: relative;">
                                <paper-card 
                                    :paper="paper"
                                    :collections="collections"
                                    @add-to-collection="addToCollection"
                                />
                                <el-button 
                                    size="small" 
                                    type="danger" 
                                    text
                                    style="position: absolute; top: 20px; right: 20px;"
                                    @click="removePaperFromCollection(paper.id)"
                                >
                                    ç§»é™¤
                                </el-button>
                            </div>
                        </div>
                    </div>
                </div>

                <el-dialog v-model="showCreateCollection" :title="editingCollection ? 'ç¼–è¾‘è®ºæ–‡é›†' : 'æ–°å»ºè®ºæ–‡é›†'" width="400px">
                    <el-form label-width="80px">
                        <el-form-item label="åç§°" required>
                            <el-input v-model="newCollection.name" placeholder="è¾“å…¥è®ºæ–‡é›†åç§°"></el-input>
                        </el-form-item>
                        <el-form-item label="æè¿°">
                            <el-input v-model="newCollection.description" type="textarea" placeholder="è¾“å…¥æè¿°ï¼ˆå¯é€‰ï¼‰"></el-input>
                        </el-form-item>
                        <el-form-item label="é¢œè‰²">
                            <el-color-picker v-model="newCollection.color"></el-color-picker>
                        </el-form-item>
                    </el-form>
                    <template #footer>
                        <el-button @click="cancelCollectionDialog">å–æ¶ˆ</el-button>
                        <el-button type="primary" @click="saveCollection" :loading="savingCollection">
                            {{ editingCollection ? 'ä¿å­˜' : 'åˆ›å»º' }}
                        </el-button>
                    </template>
                </el-dialog>

                <el-dialog v-model="showDeleteConfirm" title="ç¡®è®¤åˆ é™¤" width="400px">
                    <p>ç¡®å®šè¦åˆ é™¤è®ºæ–‡é›† "{{ deletingCollection?.name }}" å—ï¼Ÿ</p>
                    <p style="color: #909399; margin-top: 10px;">åˆ é™¤åæ— æ³•æ¢å¤ï¼Œè®ºæ–‡é›†ä¸­çš„è®ºæ–‡ä¸ä¼šè¢«åˆ é™¤ã€‚</p>
                    <template #footer>
                        <el-button @click="showDeleteConfirm = false">å–æ¶ˆ</el-button>
                        <el-button type="danger" @click="deleteCollection" :loading="deletingCollectionInProgress">åˆ é™¤</el-button>
                    </template>
                </el-dialog>

                <el-dialog v-model="showAddToCollection" title="æ·»åŠ åˆ°è®ºæ–‡é›†" width="400px">
                    <el-select v-model="selectedCollectionId" placeholder="é€‰æ‹©è®ºæ–‡é›†" style="width: 100%;">
                        <el-option v-for="col in collections" :key="col.id" :label="col.name" :value="col.id">
                            <span :style="{ color: col.color }">â—</span>
                            <span style="margin-left: 8px;">{{ col.name }}</span>
                        </el-option>
                    </el-select>
                    <template #footer>
                        <el-button @click="showAddToCollection = false">å–æ¶ˆ</el-button>
                        <el-button type="primary" @click="confirmAddToCollection" :loading="addingToCollection">ç¡®å®š</el-button>
                    </template>
                </el-dialog>
            </main>
        </div>
    </div>

    <link rel="stylesheet" href="https://unpkg.com/element-plus/dist/index.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/element-plus"></script>
    <script src="https://unpkg.com/@element-plus/icons-vue"></script>
    <script src="https://unpkg.com/echarts@5/dist/echarts.min.js"></script>
    <script>
        const { createApp, ref, onMounted, watch, computed, nextTick } = Vue;

        const PaperCard = {
            props: ['paper', 'collections'],
            emits: ['add-to-collection'],
            template: `
                <div class="paper-card">
                    <div class="paper-title" @click="openArxiv(paper.arxiv_id)">
                        {{ paper.title }}
                    </div>
                    <div v-if="paper.title_translation" class="paper-title-cn">
                        {{ paper.title_translation }}
                    </div>
                    <div class="paper-meta">
                        <span class="paper-meta-item">
                            <el-icon><User /></el-icon>
                            {{ formatAuthors(paper.authors) }}
                        </span>
                        <span class="paper-meta-item">
                            <el-icon><Calendar /></el-icon>
                            {{ formatDate(paper.published) }}
                        </span>
                        <span class="paper-meta-item">
                            <el-icon><Document /></el-icon>
                            {{ paper.arxiv_id }}
                        </span>
                        <span class="paper-relevance">
                            <span class="star" v-for="n in paper.relevance_score" :key="n">â˜…</span>
                            <span v-for="n in (5 - paper.relevance_score)" :key="'empty'+n">â˜†</span>
                        </span>
                    </div>
                    <div v-if="paper.category_explanation" class="paper-category">
                        {{ paper.category_explanation }}
                    </div>
                    <div v-if="!expanded" class="paper-abstract-preview">
                        {{ paper.abstract?.slice(0, 200) }}...
                    </div>
                    <div class="expand-btn" @click="expanded = !expanded">
                        <el-icon><component :is="expanded ? 'ArrowUp' : 'ArrowDown'" /></el-icon>
                        {{ expanded ? 'æ”¶èµ·è¯¦æƒ…' : 'å±•å¼€è¯¦æƒ…' }}
                    </div>
                    <div v-if="expanded" class="paper-detail">
                        <div v-if="paper.figure_url" class="paper-figure">
                            <img :src="paper.figure_url" alt="Paper Figure" @click="openImage(paper.figure_url)" />
                        </div>
                        <div v-if="paper.key_findings && paper.key_findings.length > 0" class="key-findings">
                            <h4>ğŸ” å…³é”®å‘ç°</h4>
                            <ul>
                                <li v-for="(finding, index) in paper.key_findings" :key="index">{{ finding }}</li>
                            </ul>
                        </div>
                        <div class="abstract-section">
                            <h4>ğŸ“„ å®Œæ•´æ‘˜è¦</h4>
                            <p>{{ paper.abstract }}</p>
                        </div>
                        <div v-if="paper.abstract_translation" class="abstract-section">
                            <h4>ğŸ‡¨ğŸ‡³ ä¸­æ–‡ç¿»è¯‘</h4>
                            <div class="translation">
                                <p>{{ paper.abstract_translation }}</p>
                            </div>
                        </div>
                        <div class="paper-actions" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ebeef5;">
                            <el-button size="small" @click="openPdf(paper.pdf_url)">
                                <el-icon><Document /></el-icon> PDF
                            </el-button>
                            <el-button size="small" @click="openArxiv(paper.arxiv_id)">
                                <el-icon><Link /></el-icon> arXiv
                            </el-button>
                            <el-button size="small" type="primary" @click="$emit('add-to-collection', paper)">
                                <el-icon><FolderAdd /></el-icon> åŠ å…¥è®ºæ–‡é›†
                            </el-button>
                        </div>
                    </div>
                    <div v-else class="paper-actions">
                        <el-button size="small" @click="openPdf(paper.pdf_url)">
                            <el-icon><Document /></el-icon> PDF
                        </el-button>
                        <el-button size="small" @click="openArxiv(paper.arxiv_id)">
                            <el-icon><Link /></el-icon> arXiv
                        </el-button>
                        <el-button size="small" type="primary" @click="$emit('add-to-collection', paper)">
                            <el-icon><FolderAdd /></el-icon> åŠ å…¥è®ºæ–‡é›†
                        </el-button>
                    </div>
                </div>
            `,
            setup() {
                const expanded = ref(false);
                
                const formatAuthors = (authors) => {
                    if (!authors || !Array.isArray(authors)) return '';
                    const names = authors.slice(0, 3).map(a => a.name);
                    if (authors.length > 3) names.push('ç­‰');
                    return names.join(', ');
                };
                
                const formatDate = (dateStr) => {
                    if (!dateStr) return '';
                    return dateStr.split('T')[0];
                };
                
                const openPdf = (url) => window.open(url, '_blank');
                const openArxiv = (arxivId) => window.open(`https://arxiv.org/abs/${arxivId}`, '_blank');
                const openImage = (url) => window.open(url, '_blank');
                
                return { expanded, formatAuthors, formatDate, openPdf, openArxiv, openImage };
            }
        };

        const app = createApp({
            components: { PaperCard },
            setup() {
                const activeTab = ref('sync');
                const stats = ref(null);
                const recentPapers = ref([]);
                const searchResults = ref([]);
                const collections = ref([]);
                const loadingRecent = ref(false);
                const updatingRecent = ref(false);
                const recentLogs = ref([]);
                const recentDays = ref('7');
                const recentLimit = ref('64');
                const recentNeedSync = ref(false);
                const recentSyncYears = ref('3');
                const recentCategories = ref([]);
                const searching = ref(false);
                const searchQuery = ref('');
                const searchDays = ref('0');
                const searchLogs = ref([]);
                
                const syncStatus = ref(null);
                const syncing = ref(false);
                const syncLogs = ref([]);
                const syncYearsBack = ref('5');
                const syncForce = ref(false);
                
                const showCreateCollection = ref(false);
                const showAddToCollection = ref(false);
                const showDeleteConfirm = ref(false);
                const newCollection = ref({ name: '', description: '', color: '#409EFF' });
                const editingCollection = ref(null);
                const deletingCollection = ref(null);
                const savingCollection = ref(false);
                const deletingCollectionInProgress = ref(false);
                const selectedCollectionId = ref(null);
                const selectedPaper = ref(null);
                const addingToCollection = ref(false);
                const viewingCollection = ref(null);
                const collectionPapers = ref([]);
                const loadingCollectionPapers = ref(false);

                const API_BASE = '/api';

                const categoryOptions = [
                    { value: 'cond-mat', label: 'cond-mat (å‡èšæ€ç‰©ç†)' },
                    { value: 'cond-mat.mtrl-sci', label: 'cond-mat.mtrl-sci (ææ–™ç§‘å­¦)' },
                    { value: 'cond-mat.str-el', label: 'cond-mat.str-el (å¼ºå…³è”ç”µå­)' },
                    { value: 'cond-mat.supr-con', label: 'cond-mat.supr-con (è¶…å¯¼)' },
                    { value: 'cond-mat.mes-hall', label: 'cond-mat.mes-hall (ä»‹è§‚ç³»ç»Ÿ)' },
                    { value: 'physics.comp-ph', label: 'physics.comp-ph (è®¡ç®—ç‰©ç†)' },
                    { value: 'physics.chem-ph', label: 'physics.chem-ph (åŒ–å­¦ç‰©ç†)' },
                    { value: 'quant-ph', label: 'quant-ph (é‡å­ç‰©ç†)' },
                    { value: 'cs.LG', label: 'cs.LG (æœºå™¨å­¦ä¹ )' },
                    { value: 'cs.AI', label: 'cs.AI (äººå·¥æ™ºèƒ½)' },
                    { value: 'cs.CV', label: 'cs.CV (è®¡ç®—æœºè§†è§‰)' },
                    { value: 'cs.CL', label: 'cs.CL (è®¡ç®—è¯­è¨€å­¦)' },
                    { value: 'cs.NE', label: 'cs.NE (ç¥ç»ç½‘ç»œ)' },
                    { value: 'stat.ML', label: 'stat.ML (ç»Ÿè®¡æœºå™¨å­¦ä¹ )' },
                    { value: 'math.NA', label: 'math.NA (æ•°å€¼åˆ†æ)' },
                    { value: 'math.OC', label: 'math.OC (ä¼˜åŒ–ä¸æ§åˆ¶)' },
                ];

                const daysOptions = [
                    { value: '3', label: 'æœ€è¿‘3å¤©' },
                    { value: '7', label: 'æœ€è¿‘7å¤©' },
                    { value: '14', label: 'æœ€è¿‘14å¤©' },
                    { value: '30', label: 'æœ€è¿‘30å¤©' },
                ];

                const limitOptions = [
                    { value: '20', label: '20' },
                    { value: '50', label: '50' },
                    { value: '64', label: '64' },
                    { value: '100', label: '100' },
                    { value: '200', label: '200' },
                ];

                const syncYearOptions = [
                    { value: '1', label: '1å¹´' },
                    { value: '2', label: '2å¹´' },
                    { value: '3', label: '3å¹´' },
                    { value: '5', label: '5å¹´' },
                ];

                const syncYearsBackOptions = [
                    { value: '1', label: '1 å¹´' },
                    { value: '2', label: '2 å¹´' },
                    { value: '3', label: '3 å¹´' },
                    { value: '5', label: '5 å¹´' },
                    { value: '10', label: '10 å¹´' },
                    { value: '15', label: '15 å¹´' },
                    { value: '20', label: '20 å¹´' },
                ];

                const searchDaysOptions = [
                    { value: '0', label: 'å…¨éƒ¨' },
                    { value: '7', label: 'æœ€è¿‘7å¤©' },
                    { value: '30', label: 'æœ€è¿‘30å¤©' },
                    { value: '90', label: 'æœ€è¿‘90å¤©' },
                    { value: '365', label: 'æœ€è¿‘1å¹´' },
                ];

                let yearChart = null;
                let categoryChart = null;

                const recentCacheStatus = computed(() => {
                    const cache = recentPapers.value._cacheInfo;
                    if (!cache || !cache.updated_at) return 'æœªç¼“å­˜';
                    const date = new Date(cache.updated_at);
                    const now = new Date();
                    const diffMins = Math.floor((now - date) / 60000);
                    const diffHours = Math.floor(diffMins / 60);
                    const diffDays = Math.floor(diffHours / 24);
                    
                    if (diffMins < 1) return 'åˆšåˆšæ›´æ–°';
                    if (diffMins < 60) return `${diffMins} åˆ†é’Ÿå‰æ›´æ–°`;
                    if (diffHours < 24) return `${diffHours} å°æ—¶å‰æ›´æ–°`;
                    return `${diffDays} å¤©å‰æ›´æ–°`;
                });

                const syncStatusText = computed(() => {
                    if (syncing.value) return 'åŒæ­¥ä¸­';
                    if (syncStatus.value?.current_task) return 'å¤„ç†ä¸­';
                    if (syncStatus.value?.last_sync?.status === 'completed') return 'æ­£å¸¸';
                    if (syncStatus.value?.last_sync?.status === 'failed') return 'å¤±è´¥';
                    return 'æœªåŒæ­¥';
                });

                const syncStatusClass = computed(() => {
                    if (syncing.value || syncStatus.value?.current_task) return 'warning';
                    if (syncStatus.value?.last_sync?.status === 'completed') return 'success';
                    return '';
                });

                const syncTimeClass = computed(() => {
                    if (!syncStatus.value?.last_sync?.time) return '';
                    const lastSync = new Date(syncStatus.value.last_sync.time);
                    const hours = (Date.now() - lastSync) / (1000 * 60 * 60);
                    if (hours < 24) return 'success';
                    if (hours < 72) return 'warning';
                    return '';
                });

                function formatSyncTime(timeStr) {
                    if (!timeStr) return 'ä»æœªåŒæ­¥';
                    const date = new Date(timeStr);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / 60000);
                    const diffHours = Math.floor(diffMs / 3600000);
                    const diffDays = Math.floor(diffMs / 86400000);
                    
                    if (diffMins < 1) return 'åˆšåˆš';
                    if (diffMins < 60) return `${diffMins} åˆ†é’Ÿå‰`;
                    if (diffHours < 24) return `${diffHours} å°æ—¶å‰`;
                    if (diffDays < 7) return `${diffDays} å¤©å‰`;
                    return date.toLocaleDateString('zh-CN');
                }

                function initCharts() {
                    if (!window.echarts) return;
                    
                    yearChart = echarts.init(document.getElementById('yearChart'));
                    categoryChart = echarts.init(document.getElementById('categoryChart'));
                }

                function renderYearChart(yearData) {
                    if (!yearChart || !yearData) return;
                    
                    const years = Object.keys(yearData).sort();
                    const values = years.map(y => yearData[y]);
                    
                    yearChart.setOption({
                        tooltip: { trigger: 'axis' },
                        grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                        xAxis: { type: 'category', data: years },
                        yAxis: { type: 'value' },
                        series: [{
                            name: 'è®ºæ–‡æ•°',
                            type: 'bar',
                            data: values,
                            itemStyle: { color: '#667eea' }
                        }]
                    });
                }

                function renderCategoryChart(categoryData) {
                    if (!categoryChart || !categoryData) return;
                    
                    const names = categoryData.map(c => c.name.length > 20 ? c.name.slice(0, 20) + '...' : c.name);
                    const values = categoryData.map(c => c.count);
                    
                    categoryChart.setOption({
                        tooltip: { trigger: 'axis', axisPointer: { type: 'shadow' } },
                        grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true },
                        xAxis: { type: 'value' },
                        yAxis: { type: 'category', data: names.reverse(), axisLabel: { fontSize: 11 } },
                        series: [{
                            name: 'è®ºæ–‡æ•°',
                            type: 'bar',
                            data: values.reverse(),
                            itemStyle: { color: '#764ba2' }
                        }]
                    });
                }

                async function fetchStats() {
                    try {
                        const res = await fetch(`${API_BASE}/stats`);
                        stats.value = await res.json();
                        
                        await nextTick();
                        
                        if (!yearChart) initCharts();
                        if (stats.value) {
                            renderYearChart(stats.value.years);
                            renderCategoryChart(stats.value.categories?.top);
                        }
                    } catch (e) {
                        console.error('Failed to fetch stats:', e);
                    }
                }

                async function fetchRecentCache() {
                    loadingRecent.value = true;
                    try {
                        const res = await fetch(`${API_BASE}/papers/recent/cache`);
                        const data = await res.json();
                        recentPapers.value = data.papers || [];
                        recentPapers.value._cacheInfo = {
                            cached: data.cached,
                            updated_at: data.updated_at,
                            days_back: data.days_back
                        };
                    } catch (e) {
                        console.error('Failed to fetch recent cache:', e);
                    } finally {
                        loadingRecent.value = false;
                    }
                }

                async function updateRecentPapers() {
                    updatingRecent.value = true;
                    recentLogs.value = [];
                    
                    try {
                        const params = new URLSearchParams({
                            days: parseInt(recentDays.value),
                            limit: parseInt(recentLimit.value),
                            need_sync: recentNeedSync.value,
                            sync_years: parseInt(recentSyncYears.value)
                        });
                        
                        if (recentCategories.value.length > 0) {
                            params.append('categories', recentCategories.value.join(','));
                        }
                        
                        const response = await fetch(`${API_BASE}/papers/recent/update?${params}`, { method: 'POST' });
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || '';
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.slice(6));
                                        
                                        if (data.type === 'log') {
                                            recentLogs.value.push({ type: 'info', message: data.message });
                                        } else if (data.type === 'result') {
                                            recentLogs.value.push({ type: 'success', message: `[${data.index}/${data.total}] ${data.paper.title.slice(0, 40)}...` });
                                        } else if (data.type === 'done') {
                                            recentLogs.value.push({ type: 'success', message: `æ›´æ–°å®Œæˆï¼Œå…± ${data.total} ç¯‡è®ºæ–‡` });
                                            fetchRecentCache();
                                        }
                                    } catch (e) {
                                        console.error('Parse error:', e);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Update error:', e);
                        recentLogs.value.push({ type: 'error', message: `æ›´æ–°å‡ºé”™: ${e.message}` });
                    } finally {
                        updatingRecent.value = false;
                    }
                }

                async function fetchSyncStatus() {
                    try {
                        const res = await fetch(`${API_BASE}/tasks/status`);
                        syncStatus.value = await res.json();
                    } catch (e) {
                        console.error('Failed to fetch sync status:', e);
                    }
                }

                async function startSearch() {
                    if (!searchQuery.value.trim()) return;
                    
                    searching.value = true;
                    searchResults.value = [];
                    searchLogs.value = [];
                    
                    try {
                        const params = new URLSearchParams({
                            q: searchQuery.value,
                            limit: 20
                        });
                        const daysValue = parseInt(searchDays.value);
                        if (daysValue > 0) {
                            params.append('days', daysValue);
                        }
                        
                        const response = await fetch(`${API_BASE}/papers/search/stream?${params}`);
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || '';
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.slice(6));
                                        
                                        if (data.type === 'log') {
                                            searchLogs.value.push({ type: 'info', message: data.message });
                                        } else if (data.type === 'ai_parsed') {
                                            searchLogs.value.push({ type: 'ai', message: `AI è§£ææœç´¢è¯: ${data.terms.join(', ')}` });
                                        } else if (data.type === 'result') {
                                            searchLogs.value.push({ type: 'success', message: `[${data.index}/${data.total}] åŠ è½½è®ºæ–‡: ${data.paper.title.slice(0, 50)}...` });
                                            searchResults.value.push(data.paper);
                                        } else if (data.type === 'done') {
                                            searchLogs.value.push({ type: 'success', message: `æœç´¢å®Œæˆï¼Œå…±æ‰¾åˆ° ${data.total} ç¯‡è®ºæ–‡` });
                                        }
                                    } catch (e) {
                                        console.error('Parse error:', e);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Search error:', e);
                        searchLogs.value.push({ type: 'error', message: `æœç´¢å‡ºé”™: ${e.message}` });
                    } finally {
                        searching.value = false;
                    }
                }

                async function startSync() {
                    syncing.value = true;
                    syncLogs.value = [];
                    
                    try {
                        const params = new URLSearchParams({
                            years_back: parseInt(syncYearsBack.value),
                            force: syncForce.value
                        });
                        
                        const response = await fetch(`${API_BASE}/tasks/sync?${params}`, { method: 'POST' });
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || '';
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.slice(6));
                                        
                                        if (data.type === 'log') {
                                            syncLogs.value.push({ type: 'info', message: data.message });
                                        } else if (data.type === 'progress') {
                                            syncLogs.value.push({ type: 'progress', message: `è¿›åº¦: ${data.current}/${data.total}` });
                                        } else if (data.type === 'done') {
                                            syncLogs.value.push({ type: 'success', message: `åŒæ­¥å®Œæˆï¼Œå…±æ·»åŠ  ${data.papers_added} ç¯‡è®ºæ–‡` });
                                            fetchStats();
                                            fetchSyncStatus();
                                            fetchRecentCache();
                                        } else if (data.type === 'error') {
                                            syncLogs.value.push({ type: 'error', message: data.message });
                                        }
                                    } catch (e) {
                                        console.error('Parse error:', e);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Sync error:', e);
                        syncLogs.value.push({ type: 'error', message: `åŒæ­¥å‡ºé”™: ${e.message}` });
                    } finally {
                        syncing.value = false;
                    }
                }

                async function fetchCollections() {
                    try {
                        const res = await fetch(`${API_BASE}/collections`);
                        collections.value = await res.json() || [];
                    } catch (e) {
                        console.error('Failed to fetch collections:', e);
                    }
                }

                async function saveCollection() {
                    if (!newCollection.value.name.trim()) {
                        ElementPlus.ElMessage.warning('è¯·è¾“å…¥è®ºæ–‡é›†åç§°');
                        return;
                    }
                    savingCollection.value = true;
                    try {
                        if (editingCollection.value) {
                            const res = await fetch(`${API_BASE}/collections/${editingCollection.value.id}`, {
                                method: 'PUT',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(newCollection.value)
                            });
                            if (!res.ok) {
                                const data = await res.json();
                                throw new Error(data.detail || 'æ›´æ–°å¤±è´¥');
                            }
                            ElementPlus.ElMessage.success('è®ºæ–‡é›†æ›´æ–°æˆåŠŸ');
                        } else {
                            const res = await fetch(`${API_BASE}/collections`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(newCollection.value)
                            });
                            if (!res.ok) {
                                const data = await res.json();
                                throw new Error(data.detail || 'åˆ›å»ºå¤±è´¥');
                            }
                            ElementPlus.ElMessage.success('è®ºæ–‡é›†åˆ›å»ºæˆåŠŸ');
                        }
                        showCreateCollection.value = false;
                        newCollection.value = { name: '', description: '', color: '#409EFF' };
                        editingCollection.value = null;
                        fetchCollections();
                    } catch (e) {
                        ElementPlus.ElMessage.error(e.message || 'æ“ä½œå¤±è´¥');
                    } finally {
                        savingCollection.value = false;
                    }
                }

                function cancelCollectionDialog() {
                    showCreateCollection.value = false;
                    newCollection.value = { name: '', description: '', color: '#409EFF' };
                    editingCollection.value = null;
                }

                function openEditCollection(col) {
                    editingCollection.value = col;
                    newCollection.value = { 
                        name: col.name, 
                        description: col.description || '', 
                        color: col.color || '#409EFF' 
                    };
                    showCreateCollection.value = true;
                }

                function confirmDeleteCollection(col) {
                    deletingCollection.value = col;
                    showDeleteConfirm.value = true;
                }

                async function deleteCollection() {
                    if (!deletingCollection.value) return;
                    deletingCollectionInProgress.value = true;
                    try {
                        const res = await fetch(`${API_BASE}/collections/${deletingCollection.value.id}`, {
                            method: 'DELETE'
                        });
                        if (res.ok) {
                            showDeleteConfirm.value = false;
                            ElementPlus.ElMessage.success('è®ºæ–‡é›†å·²åˆ é™¤');
                            fetchCollections();
                            if (viewingCollection.value?.id === deletingCollection.value.id) {
                                viewingCollection.value = null;
                            }
                            deletingCollection.value = null;
                        } else {
                            const data = await res.json();
                            ElementPlus.ElMessage.error(data.detail || 'åˆ é™¤å¤±è´¥');
                        }
                    } catch (e) {
                        console.error('Failed to delete collection:', e);
                        ElementPlus.ElMessage.error('åˆ é™¤å¤±è´¥');
                    } finally {
                        deletingCollectionInProgress.value = false;
                    }
                }

                async function openCollectionDetail(col) {
                    viewingCollection.value = col;
                    loadingCollectionPapers.value = true;
                    collectionPapers.value = [];
                    try {
                        const res = await fetch(`${API_BASE}/collections/${col.id}`);
                        const data = await res.json();
                        collectionPapers.value = data.papers || [];
                    } catch (e) {
                        console.error('Failed to fetch collection papers:', e);
                        ElementPlus.ElMessage.error('åŠ è½½è®ºæ–‡åˆ—è¡¨å¤±è´¥');
                    } finally {
                        loadingCollectionPapers.value = false;
                    }
                }

                async function removePaperFromCollection(paperId) {
                    if (!viewingCollection.value) return;
                    try {
                        const res = await fetch(
                            `${API_BASE}/collections/${viewingCollection.value.id}/papers/${paperId}`,
                            { method: 'DELETE' }
                        );
                        if (res.ok) {
                            collectionPapers.value = collectionPapers.value.filter(p => p.id !== paperId);
                            ElementPlus.ElMessage.success('å·²ä»è®ºæ–‡é›†ä¸­ç§»é™¤');
                            fetchCollections();
                        } else {
                            const data = await res.json();
                            ElementPlus.ElMessage.error(data.detail || 'ç§»é™¤å¤±è´¥');
                        }
                    } catch (e) {
                        console.error('Failed to remove paper:', e);
                        ElementPlus.ElMessage.error('ç§»é™¤å¤±è´¥');
                    }
                }

                function addToCollection(paper) {
                    selectedPaper.value = paper;
                    showAddToCollection.value = true;
                }

                async function confirmAddToCollection() {
                    if (!selectedCollectionId.value || !selectedPaper.value) return;
                    addingToCollection.value = true;
                    try {
                        const res = await fetch(`${API_BASE}/collections/${selectedCollectionId.value}/papers`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ paper_id: selectedPaper.value.id })
                        });
                        if (res.ok) {
                            showAddToCollection.value = false;
                            selectedPaper.value = null;
                            ElementPlus.ElMessage.success('å·²æ·»åŠ åˆ°è®ºæ–‡é›†');
                            fetchCollections();
                        } else {
                            const data = await res.json();
                            ElementPlus.ElMessage.error(data.detail || 'æ·»åŠ å¤±è´¥');
                        }
                    } catch (e) {
                        console.error('Failed to add to collection:', e);
                        ElementPlus.ElMessage.error('æ·»åŠ å¤±è´¥');
                    } finally {
                        addingToCollection.value = false;
                    }
                }

                watch(activeTab, (newTab) => {
                    if (newTab === 'sync') {
                        nextTick(() => {
                            if (!yearChart) initCharts();
                            if (stats.value) {
                                renderYearChart(stats.value.years);
                                renderCategoryChart(stats.value.categories?.top);
                            }
                        });
                    }
                });

                onMounted(() => {
                    fetchStats();
                    fetchRecentCache();
                    fetchCollections();
                    fetchSyncStatus();
                });

                return {
                    activeTab, stats, recentPapers, searchResults, collections, 
                    loadingRecent, updatingRecent, recentLogs,
                    recentDays, recentLimit, recentNeedSync, recentSyncYears, recentCategories,
                    categoryOptions, daysOptions, limitOptions, syncYearOptions, syncYearsBackOptions, searchDaysOptions,
                    searching, searchQuery, searchDays, searchLogs,
                    syncStatus, syncing, syncLogs, syncYearsBack, syncForce,
                    syncStatusText, syncStatusClass, syncTimeClass, formatSyncTime,
                    recentCacheStatus,
                    showCreateCollection, showAddToCollection, showDeleteConfirm,
                    newCollection, editingCollection, deletingCollection,
                    savingCollection, deletingCollectionInProgress,
                    selectedCollectionId, selectedPaper, addingToCollection,
                    viewingCollection, collectionPapers, loadingCollectionPapers,
                    fetchStats, fetchRecentCache, updateRecentPapers, startSearch, fetchCollections,
                    fetchSyncStatus, startSync,
                    saveCollection, cancelCollectionDialog, openEditCollection,
                    confirmDeleteCollection, deleteCollection,
                    openCollectionDetail, removePaperFromCollection,
                    addToCollection, confirmAddToCollection
                };
            }
        });

        app.use(ElementPlus);
        if (window.ElementPlusIconsVue) {
            for (const [key, component] of Object.entries(window.ElementPlusIconsVue)) {
                app.component(key, component);
            }
        }
        app.mount('#app');
    </script>
</body>
</html>
